date: 2012-10-17
layout: post
title: "OS Project"
description: ""
category: "学习"
tags: [OS, Linux kernel]
published: true

## SECTION 1
操作系统课要做一个presentation和报告。要求对Linux源码某一部分分析。我要对内存管理这一块进行分析。

内核版本：`2.6.32.60 `  
工具：Source Insight 3.5  
平台：i386

现在直接看内核源码中内存管理如何实现估计会摸不到头脑，参照这个文档[Linux内存管理][1]。文档中的分析方式是
>以应用程序开发者的角度审视Linux的进程内存管理，在此基础上逐步深入到内核中讨论系统物理内存管理和内核内存的使用方法。

### 进程内存空间  
##### **进程内存空间**  
在32位的机器上，进程看到的空间是块大小为4G大小的线性虚拟空间。而这4G的空间又分为：

* 内核空间：大小1G,3~4G，这部分是固定的不会跟着进程的切换、改变而改变。
* 用户空间：大小3G，0~3G，每个进程对应自己的用户空间，进程切换时会跟着进程而改变。

内核进程可以访问用户空间和内核空间(额，这是废话)。但是，当用户空间访问内核空间时。只能使用以下几种方式：

- 系统调用的方式（同步中断）
- 中断的方式
- 坑

每个进程的内存空间使用了5个数据区：

* 代码段： 存放可执行文件的操作指令。为了保护，一般不可写。
* 数据段： 存放程序中已经初始化的全局变量。（如c语言中的初始化的全局变量和static关键字声明的变量）
* BSS段： 存放未初始化的全局变量，内存中bss段全部置0
* 堆：存放动态分配的内存段
* 栈：存放局部变量、函数调用时的参数

#### **进程内存管理**
进程内存空间中有多个内存区域，每个区域可以用一个结构体vm\_area\_struct来描述，这些区域用链表的方式链接。同时，为了查找方便，vm\_area\_struct同时使用了红黑树（**坑**）。

#### **物理内存**
进程访问一个虚拟地址时，首先要把虚拟地址转化成物理地址。这个过程需要查询页表完成。

#### Just Read the Fucking code
源码位置：  
/mm  
/arch/x86/mm

另：  
1. 为什么要有保护模式？参考[I386体系结构][2]

* 操作系统提供多任务的功能，有义务让任务间彼此隔离，这依赖保护模式
* 操作系统本身的代码要贮存在内存中，需要对这块内存提供保护，不能任由应用程序访问

[1]: http://www.kerneltravel.net/journal/v/mem.htm  "Linux内存管理"
[2]: http://www.kerneltravel.net/journal/ii/part1.htm "I386的体系结构"

## SECTION 2
参考基本关于内核的书（《Understanding the Linux Kernel,3rd Edition》、《Linux 内核设计与实现 第二版》、《深入Linux内核架构》）的目录，关于内存管理的部分主要分为三个部分：

- 内存管理
- 进程地址空间
- 页缓存和回写

这三个部分我们小组每人负责一个部分，我负责<del>进程地址空间部分</del><ins>内存管理中内存区管理部分</ins>。

### **进程地址空间**：

- 内存描述符 
	- `mm_struct`
	- `mm_count`,`mm_users`
	- 链表结构
- 内核线程的内存描述符
- 线性区(Memory Regions)
	- `vm_area_struct`
	- 增加或删除一个线性地址空间
	- 线性地址空间、内存描述符、线性区三者对应的关系
	- 红-黑树(red-black tree)
		- 性质
		- 优点
		- 操作(普通二叉树操作+标记颜色) 旋转
			- 插入
			- 删除 转化为删除只有一个儿子（非叶子）的节点
	- 线性区访问权限  `vm_flags`字段
	- 线性区的处理
		- `find_vma()`
		- `find_vma_intersection()`
		- `get_unmapped_area()`
		- `insert_vm_struct()`
	- 分配线性地址区间
		- `do_mmap`
	- 释放线性地址区间
		- `do_munmap()`
		- `split_vma()`
		- `unmap_region()`
- 缺页异常处理程序
	- `do_page_fault()`
	- 处理地址空间以外的错误地址
	- 处理地址空间内的错误地址
	- 请求调页
	- 写时复制
	- 处理非连续内存区访问
- 创建和删除进程的地址空间
	- 创建进程的地址空间
	- 删除进程的地址空间
- 堆的管理

### **内存管理**  
包括三个部分，页框管理、内存区管理以及非连续内存区管理，前面两个是对连续物理内存区处理的两种不同技术。

1. **页框管理**
	- 页描述符  
	  page结构体 描述页框的相关信息
	- NUMA非一致内存访问  
	  给定CPU对不同内存单元的访问时间可能不一样。把物理内存划分为几个节点（node）。每个节点又分为几个管理区。
		- 节点描述符  
		`pg_data_t`结构体，所有的节点描述符放在一个单向链表中。在Linux中，为了兼容UMA和NUMA，一直使用节点，在UMA中链表中只有一个元素即只有一个节点，它包含了系统中所有的物理内存。一切都是为了可移植性！
	- 内存管理区  
	80X86体系结构的两种硬件约束：
		- ISA总线的DMA处理器，只能对RAM的前16MB进行寻址
		- RAM大的32位计算机中，CPU不能直接访问所有的物理内存，线性地址空间太小。  
	Linux的解决办法，把每个内存节点划分为3个管理区(zone)。
		- `ZONE_DMA`
		包含低于16MB的内存页框
		- `ZONE_NORMAL`
		包含高于16MB且低于896MB的内存页框
		- `ZONE_HIGHMEM`
		包含从896MB开始高于896MB的内存页框  
	低于896MB的内存页框映射到线性地址空间的第4个GB，即3G～4G。`ZONE_HIGHMEM`区包含的内存页不能由内核直接访问  
	每个内存管理区都有自己的描述符  
	内核调用内存分配函数时，必须指明请求页框所在的管理区。  
	- 保留的页框池  
	当没有足够的空闲内存满足请求时，必须回收一些内存。当请求内存时，一些内核控制路径（使用了原子标志）不能被阻塞。没有足够的空闲页，则仅仅是分配失败。为了减少原子内存分配失败的情况，内核为其保留了一个页框池。只有在内存不足时才使用。  
	保留池大小=。。。。（KB）  
	管理区描述符的`page_min`字段表示管理区内保留的页框的数目
	- 分区页框分配器  
	该内核子系统处理对连续页框组的内存分配请求。即分配的对象是连续的多个页框。  
		- 请求和释放页框  
		相关函数`alloc_pages(gfp_mask,order)` `alloc_page(gfp_mask)` `__get_free_pages(gfp_mask,order)` `__get_free_page(gfp_mask)`
			- 用于请求页框的标志
	- 高端内存页框的内核映射  
	32位的系统上，896MB边界以上的页款不映射在内核线性地址空间的第4个GB。在64位的硬件平台上，因为可用的线性地址空间远大于能安装的RAM大小，所以这些体系结构的`ZONE_HIGHMEM`管理区是空的。32位平台的解决方案:
	高端内存页框的只通过`alloc_pages()`函数，这些函数不返回第一个被分配页框的线性地址。返回第一个被分配页框的**页描述符**的线性地址。
	没有线性地址的高端内存中的页框不能被内核访问。前面说到内核使用第4个G，但只使用了896MB直接映射，还剩下的128MB中的一部分专门用于映射高端内存页框。映射的方法是重复使用线性地址，是整个高端内存能够在不同的时间被访问。
	内核采用三种机制讲页框映射到高端内存  
		- 永久内核映射  
		内核建立高端页框到内核地址空间的长期映射。使用专门的页表。包含512或1024项。内核一次访问2M或4M的高端内存。页表地址放在`pkmap_page_table`中  
			- `page_address_htable`散列表
			- `page_address()`,返回页框对应的线性地址
			- `kmap()`建立永久内核映射
			- `kmap_high()` `map_new_virtual()`
			- `kunmap_high()`
		- 临时内核映射
			- `kmap_atomic()`
	- 伙伴系统算法  
	为了解决碎片问题。避免碎片的方法有两种：
		- 利用分页单元把非连续的空闲页框映射到连续的线性地址空间
		- 记录现存的空闲连续页框的情况，避免满足对小块的请求分割大的空闲块  
	内核选择第二种方法。  
	内核为每个管理区使用不同的伙伴系统  
		- 数据结构 `free_area`数组
		- 分配块
		- 释放块
	- 非连续内存分配
	- 每CPU页框高速缓存  
	内核经常请求和释放单个页框，为了提升系统性能。
		- 热高速缓存
		- 冷高速缓存
	内核通过两个位标监视热高速缓存和冷高速缓存的大小
		- 通过每CPU页框高速缓存中分配页框
		- 释放页框到每CPU页框高速缓存
	- 管理区分配器  
	分配一个包含足够多空闲页框的内存管理区，使其满足内存请求
		- `__alloc_pages()` 至此这个函数基本可以解释清了
		- `__free_pages()` 释放一组页框
2. **内存区管理**  
	关注具有连续物理地址和任意长度的内存单元序列。  
	伙伴算法解决的是页框作为基本内存区所产生的“外碎片”问题，当请求的内存很小，少于一页框的时候就会产生所谓的“内碎片”问题。Linux早期版本`具体是？`采用提供按几何分布的内存区大小,以2的幂作为大小。这样可以保证内碎片小于50%。
	- slab分配器  
	算法基于下列前提  
		- 所存放的数据类型可以影响内存区的分配方式。 
		如，分配一个页框，内核使用`get_zeroed_page()`
		slab分配器扩充了这种思想，把内存区看作object，这些object由一组数据结构和几个叫做constructor或destructor的函数组成，分别对应内存的初始化和回收。  
		避免重复初始化object，slab分配器不丢弃已分配的object，释放后仍然保存在内存中。
		- 内核函数倾向于反复请求同一类型的内存区。  
		如，进程的创建或撤销。
		- 对内存区的请求可以根据它们发生的频率来分类。  
		对预期频繁的请求，考虑使用一组适当大小的专用的对象高效处理。反之，使用几何分布大小的对象。
		- 当引入的对象大小不是几何分布的时候，可以借助处理器硬件高速缓存导致更好的性能。
		- 为了硬件高速缓存的高性能限制对伙伴系统分配器的调用。 
	slab分配器把对象分组放进高速缓存。包含高速缓存的主内存区被划分为多个slab，每个slab由一个或多个连续的页框组成，这些页框中既包含已分配的对象，也包含空闲的对象。
	<iframe src="https://skydrive.live.com/embed?cid=A1E8316CC75B7FBA&resid=A1E8316CC75B7FBA%2111698&authkey=ADw9sdC032r47vk" width="320" height="98" frameborder="0" scrolling="no"></iframe>
	- 高速缓存描述符  
	`kmem_cache_t`结构体，`kmem_list3`结构体  
	- slab描述符  
	`slab`结构体  
		- 外部slab描述符
		- 内部slab描述符
	<iframe src="https://skydrive.live.com/embed?cid=A1E8316CC75B7FBA&resid=A1E8316CC75B7FBA%2111699&authkey=AIn2a1AQKIWkhXA" width="319" height="206" frameborder="0" scrolling="no"></iframe>
	- 普通和专用高速缓存  
	普通高速缓存只由slab分配器用于自己的目的，专用的高速缓存由内核的其余部分使用。
		- 普通高速缓存  
		第一个高速缓存是`kmem_cache`，包含其余高速缓存的高速缓存描述符。另外一些高速缓存包含用作普通用途的内存区。对每种大小，都有两个高速缓存：一个适用于ISA DMA分配，另一个适用于常规分配。  

		系统初始化期间调用`kmem_cache_init()`、`kmem_cache_sizes_init()`来建立普通高速缓存。

		专业高速缓存是由`kmem_cache_create()`函数创建的。调用`kmem_cache_destroy()`撤销一个高速缓存
	- slab分配器与分区页框分配器的接口  
	`kmem_getpages()`函数、`kmem_freepages()`函数
	- 给高速缓存分配slab  
	`cache_grow()`函数  `kmem_getpages()`函数 `alloc_slabmgmt()`函数
	- 从高速缓存中释放slab  
	`slab_destroy()`函数
	- 对象描述符
		- 外部对象描述符  
		存储在slab的外面
		- 内部对象描述符  
		存放在slab内部，正好位于描述符所描述的对象之前
	- 对齐内存中的对象
	- slab着色
	- 空闲slab对象的本地高速缓存  
	类似上面的每CPU页框高速缓存
	- 分配slab对象  
	`kmem_cache_alloc()`函数  `cache_alloc_refill()`函数
	- 释放slab对象  
	`kmem_cache_free()`函数
	- 通用对象  
	`kmalloc()`函数 `kfree()`函数
	- 内存池  
	内存池被用来分配任何一种类型的动态内存，从整个内框到使用`kmallor()`分配的小内存区。
3. **非连续内存区管理**  
	Linux在为活动的交换区分配数据结构，为模块分配空间，给某些I/O驱动程序分配缓冲区
	- 非连续内存区的线性地址
	- 非连续内存区的描述符  
	`vm_struct`结构体  
	`get_vm_area()`函数，在`VMALLOC_START`和`VMLLOC_END`之间查找一个空闲区域。如果有返回起始地址。
	- 分配非连续内存区  
	`vmalloc`函数  
	`map_vm_area`函数